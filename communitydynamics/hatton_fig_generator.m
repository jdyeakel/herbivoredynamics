(* ::Package:: *)

(* ::Input:: *)
(*(* Parameters that go into the model *)*)
(*(* Those that rely on mass have been made into functions for better exploration *)*)
(**)
(*s=1.;*)
(*B0=4.7*10^(-2);*)
(*Em=5774.(*J/gram*);*)
(*Emprime =7000.;*)
(*aprime =  B0/Emprime;*)
(*\[Eta]=3./4.;*)
(*\[Gamma]=1.19;*)
(*\[Zeta]=1.00;*)
(*f0=0.0202;*)
(*mm0=0.383;*)
(*\[Alpha]=(*2.10*10^(-9)*)(9.45*10^(-9));*)
(*Ed=18200.; (*J/g*)*)
(*k=23000.;*)
(*(*\[Rho][M_]:=B0*M^(\[Eta])/(M*Ed);*)
(*Y[M_]:=M*Ed/BLam[M]; (*g individual/ g grass*)*)*)
(*\[Rho][M_,Ed_]:=B0*M^(\[Eta])/(M*Ed);*)
(*Y[M_,Ed_]:=M*Ed/BLam[M]; (*g individual/ g grass*)*)
(**)
(*a0 = 1.88*10^-8 ;(*sec grams^-b0*)*)
(*a1=1.45*10^-7;*)
(*a2=4.04*10^6;*)
(*b0=-0.56;*)
(*b1=-0.27;*)
(*b2=0.30;*)
(*\[Mu][M_] := (a0*(Exp[a1*a2*M^(b1+b2)]-1)*M^(b0-b1-b2))/(a1*a2)   (* this is the consumer survivorship mortality rate*)*)
(**)
(**)
(*B0=4.7*10^(-2);(*W g^\[Minus]0.75*)*)
(*Em=5774.;(*J/gram*)*)
(*a = B0/Em;*)
(*m0[M_]:= (.0558*(1/1000)^.92*M^0.92)*1000;*)
(*\[Epsilon]Lam = 0.95;*)
(*\[Tau]Lam[M_]:= -Log[(1-\[Epsilon]Lam^(1/4))/(1 - (m0[M]/M)^(1/4))]*(4*M^(1/4))/a;*)
(*\[Lambda][M_]:=(Log[2]/\[Tau]Lam[M]) (*Fecundity = 2*) (* max consumer growth rate *)*)
(**)
(*(*STARVATION MORTALITY*)*)
(*\[Epsilon]sig[M_] := (1-(f0*M^\[Gamma]+mm0*M^\[Zeta])/M);(*mortality from starvation state*)*)
(*\[Tau]sig [M_]:=-(M^(1/4)/aprime)*Log[\[Epsilon]sig[M]];(*time it takes to go from full to dead*)*)
(*\[Sigma][M_] := 1./\[Tau]sig [M];(*starvation mortality rate)*)*)
(**)
(*E'=7000.; (*J/g*)*)
(*a'=B0/E';*)
(*m[t_,M_]:=M*E^(-a'*t/(M^(1-\[Eta])))*)
(**)
(**)
(*(* Two version of Beta-lambda here. The first one doesn't take long to integrate numerically but gives slightly different results from the analytical version below *)*)
(*B\[Lambda][M_]=Integrate[B0*m[t,M]^(\[Eta]),{t,0,\[Tau]Lam[M]}];*)
(**)
(*BLam[M_]:=1/(3 a) E^(-((a \[Tau]Lam[M])/M^(1/4))) M^(1/4) (3 (-1+E^((a \[Tau]Lam[M])/M^(1/4))) m0[M]+M (-48 E^((3 a \[Tau]Lam[M])/(4 M^(1/4))) (-1+(m0[M]/M)^(1/4))-36 E^((a \[Tau]Lam[M])/(2 M^(1/4))) (-1+(m0[M]/M)^(1/4))^2-16 E^((a \[Tau]Lam[M])/(4 M^(1/4))) (-1+(m0[M]/M)^(1/4))^3+3 (-1+4 (m0[M]/M)^(1/4)-6 Sqrt[m0[M]/M]+4 (m0[M]/M)^(3/4))+E^((a \[Tau]Lam[M])/M^(1/4)) (-25+12 (m0[M]/M)^(1/4)+6 Sqrt[m0[M]/M]+4 (m0[M]/M)^(3/4)))+3 a E^((a \[Tau]Lam[M])/M^(1/4)) M^(3/4) \[Tau]Lam[M]);*)


(* ::Input:: *)
(**)
(**)
(**)
(*(* The allometrically determined niche model*)*)
(*(* Interactions function takes lists of organisms and masses, returns an interaction matrix*)*)
(*interactionMatrixGenerator[numberPlants_,herbivoreList_,connectance_,nicheModel_,scenario_,trophicModel_]:=Module[*)
(*{},*)
(**)
(*(* beta paramter for generating niche model ranges is derived from connectance*)*)
(*beta=((1/(2*connectance)) - 1);*)
(*alpha=1;*)
(**)
(*(* sets number of consumers and number of species based on trophic levels *)*)
(*numberHerbivores=Length[herbivoreList];*)
(*numberSpp=numberPlants+numberHerbivores;*)
(**)
(*generatePlants[numberPlants, scenario];*)
(*generateHerbivores[herbivoreList,numberPlants];*)
(**)
(*(* Sets the width (level of generalism) of consumers based on their niche value and a Beta draw*)*)
(*(* ex: {{0.2682`},{1.0504`}} *)*)
(*herbivoreNicheRange=Table[ *)
(*Which[nicheModel==1,*)
(*nicheModelRange[{herbivoreAttributes[[i,2]]}],*)
(*nicheModel==2,*)
(*inverseNicheModelRange[{herbivoreAttributes[[i,2]]}],*)
(*nicheModel==3,*)
(*parabolicNicheModelRange[{herbivoreAttributes[[i,2]]}]  *)
(*],*)
(*{i, 1, numberHerbivores}];*)
(*(* Finds the center of the trophic niche for herbivores *)*)
(*(* ex: {0.0949`,0.7768`}*)*)
(*herbivoreNicheCenter = Table[*)
(*RandomReal[Flatten[{herbivoreNicheRange[[i]]/2,herbivoreAttributes[[i,2]]}]],*)
(*{i,1,numberHerbivores}];*)
(*(* combines the center of the trophic niche with the range to create specific min/max values for plant prey *)*)
(*herbivoreNicheMin =*)
(*(* ex: {-0.03915`,0.2516`}*)Flatten[Table[herbivoreNicheCenter[[i]]-herbivoreNicheRange[[i]]/2,{i,1,numberHerbivores}]];*)
(*herbivoreNicheMax =*)
(*(* ex: {0.2291`,1.3021`}*)Flatten[Table[herbivoreNicheCenter[[i]]+herbivoreNicheRange[[i]]/2,{i,1,numberHerbivores}]];*)
(**)
(*(* adds trophic links between herbivores and plants deterministcally if plant niche falls within herb niche range*)*)
(*(* ex: {{1,2,3},{1,2,3}} *)*)
(*(*herbivorePlantNicheLinks=Table[*)
(*If[plantAttributes[[j,2]]>herbivoreNicheMin[[i]]&&plantAttributes[[j,2]]<herbivoreNicheMax[[i]],*)
(*plantAttributes[[j,1]],*)
(*0], (* I think this is forcing fully linked web *)*)
(*{i,1,numberHerbivores},{j,1,numberPlants}];*)*)
(**)
(*randoPlants=RandomSample[plantAttributes];*)
(*If[numberHerbivores==numberPlants,*)
(*pairwiseLinks=Table[*)
(*If[i==j,*)
(*randoPlants[[i,1]],*)
(*0],*)
(*{i,1,numberHerbivores},{j,1,numberPlants}],*)
(*pairwiseLinks=Null*)
(*];*)
(**)
(*fullConnectance=Table[*)
(*plantAttributes[[j,1]],*)
(*{i,1,numberHerbivores},{j,1,numberPlants}];*)
(*nicheLinks=herbivorePlantNicheLinks[plantAttributes,herbivoreAttributes,herbivoreNicheCenter,herbivoreNicheMin,herbivoreNicheMax];*)
(*ratioLinks=herbivorePlantRatioLinks[plantAttributes,herbivoreAttributes];*)
(*nRLinks=nicheRatioLinks[nicheLinks,ratioLinks];*)
(**)
(*Which[*)
(*trophicModel==0,*)
(*trophicLinks=fullConnectance,*)
(*trophicModel==1,*)
(*trophicLinks=nicheLinks,*)
(*trophicModel==2,*)
(*trophicLinks=ratioLinks,*)
(*trophicModel==3,*)
(*trophicLinks=nRLinks,*)
(*trophicModel==4,*)
(*trophicLinks=pairwiseLinks];*)
(**)
(*(* totals number of plant links each herbiovre has*)*)
(*(* ex: {{100,3},{1000,3}} *)*)
(*herbivoreGenerality=Table[*)
(*{herbivoreAttributes[[i,3]],*)
(*Count[trophicLinks[[i]],u_/;u!= 0.0]},*)
(*{i,1,numberHerbivores}];*)
(**)
(*(* gets plant data in proper form for joining with pred and herb data*)*)
(*(* ex: {{1,{}},{2,{}},{3,{}}} *)*)
(*plants =Table[*)
(*{plantAttributes[[i,1]],*)
(*{}},*)
(*{i,1,numberPlants}];*)
(**)
(*(* joins herbivore generality to niche values*)*)
(*(* {{4,{1,2,3}},{5,{1,2,3}}} *)*)
(*herbivores=Table[*)
(*{herbivoreAttributes[[i,1]],*)
(*trophicLinks[[i]]},*)
(*{i,1,numberHerbivores}];*)
(**)
(*(* joins organism data together for turning into an interaxtion matrix in foodweb *)*)
(*(* ex: {1,{}},{2,{}},{3,{}},{4,{1,2,3}},{5,{1,2,3}}} *)*)
(*trophicList = Join[plants,herbivores];*)
(**)
(**)
(*(* assembles interaction data into an interaction matrix *)*)
(*(* ex:*)
(*{{0,0,0,0,0},*)
(*{0,0,0,0,0},*)
(*{0,0,0,0,0},*)
(*{1,1,1,0,0},*)
(*{1,1,1,0,0}}*)
(**)*)
(*interactionMatrix = Table[*)
(*If[MemberQ[trophicList[[i,2]],j],*)
(*1,*)
(*0],*)
(*{i,1,numberSpp},*)
(*{j,1,numberSpp}*)
(*]*)
(*] (* this is the end of the interaction matrix generator function *)*)
(**)
(**)
(**)
(**)
(*(* generateFW takes the interaction matrix produced by "interactions" and generates a dynamical system *)*)
(**)
(**)
(*generateFW[ numberPlants_,herbivoreList_,adjM_,perAdaptive_,scenario_, T_]:= Module[*)
(*{},*)
(*numberHerbivores=Length[herbivoreList];*)
(*numberSpp=numberPlants+numberHerbivores;*)
(*numBrowse=browseGrazeSpp[numberPlants, scenario][[2]];*)
(*numGraze=browseGrazeSpp[numberPlants, scenario][[1]];*)
(**)
(*(*Define percent adaptive foragers*)*)
(*PerAdaptive = perAdaptive;     (**)*)
(**)
(*G = Table[       (* build vector of learning rates *)*)
(*rr=RandomReal[];*)
(*If[rr<PerAdaptive,      (*if random number is less than % adaptive species*)*)
(*(*RandomVariate[UniformDistribution[{0.0,5}]],*)   (*draw from a 0-5 random uniform*)*)
(*10, (* defaulting to 0.25*)*)
(*0                                                           (*otherwise set value to 0*)*)
(*],{i,1,numberSpp}];    (* run the if-statement for each i in 1:numberspecies*)*)
(**)
(*r = Table[       (* from Michaletz et al 2014 on woody plants: RandomReal[{2.81*10^-10,2.19*10^-8} (* browse*)*)
(* the value of \[Alpha] can be roughly estimated by the NPP divided by the corresponding biomass densities *)
(*grasslands from Scurlock data from nairobi:   811/144.617=1.778*10^-7 (1/s)   (lit above ground npp/ average above ground biomass   1/yr)*)
(**)*)
(*Which[*)
(*i<=numBrowse,*)
(*RandomReal[{2.81*10^-10,2.19*10^-8}], (* r of browse plants *)*)
(*i>numBrowse && i<=numBrowse + numGraze,*)
(*(1.778*10^-7)*(10^RandomReal[{-1,1}]), (* r of graze plants *)*)
(*i>numBrowse + numGraze,*)
(*1.0],*)
(*{i,1,numberSpp}];*)
(**)
(*(*s = Table[       (* build vector of ... *)*)
(*If[i \[LessEqual] numberPlants,*)
(*0.00000001*RandomReal[{0.8,1.2}],*)
(*0], *)
(*{i,1,numberSpp}*)
(*];*)*)
(**)
(*vecK=Flatten[speciesKGenerator[browseGrazeK[scenario],browseGrazeSpp[numberPlants, scenario],scenario]];*)
(**)
(**)
(*(* CWD =100-(ADL/NDF*100 (from Codron etal. 2007), their equation is *10 instead of *100, confirm before publishing*)
(*foliage average = 100-(12.1/38.1 *100) = 68.24  (range: 58.2-80.78)ish*)
(*  grass average = 100-(4.9/68.2*100)= 92.81   (range: 91.27-95.24)ish)*)
(**)*)
(*vecEd=Table[*)
(*(*Ed=18200; (*J/g*)*)*)
(*Which[*)
(*i<=numBrowse,*)
(*18200*RandomReal[{0.582,0.808}], (* Ed of browse plants *)*)
(*i>numBrowse && i<= numBrowse+numGraze,*)
(*18200*RandomReal[{0.913,0.952}], (* Ed of graze plants *)*)
(*i> numBrowse+numGraze,*)
(*1.0],*)
(*{i,1,numberSpp}];*)
(**)
(*vecY = Table[       (* build vector of ... Y[i,j] values that employs both consumer mass and plant energy density*)*)
(*Table[                        *)
(*Which[*)
(*i<= numberPlants && j <= numberPlants, *)
(*1.0,*)
(*i<=numberPlants && j> numberPlants,*)
(*Y[herbivoreAttributes[[j-numberPlants,3]],vecEd[[i]]], (* input is [consumer mass, resource energy density]*)*)
(*i>numberPlants && j<= numberPlants,*)
(*1.0,*)
(*i>numberPlants && j> numberPlants,*)
(*1.0*)
(*],*)
(*{i,1,numberSpp}], (* resources *)*)
(*{j,1, numberSpp}] ;*)
(**)
(**)
(*vec\[Sigma] = Table[       (* build vector of ... *)*)
(*If[i <= numberPlants,*)
(*0.0,*)
(*\[Sigma][herbivoreAttributes[[i-numberPlants,3]]]],*)
(*{i,1,numberSpp}*)
(*];*)
(**)
(*vec\[Lambda] = Table[       (* build vector of ... *)*)
(*If[i <= numberPlants,*)
(*0.0,*)
(*\[Lambda][herbivoreAttributes[[i-numberPlants,3]]]],{i,1,numberSpp}*)
(*];*)
(**)
(*( *)
(*(*Define population equations*)*)
(*(*eqnX =       (* create a table of equations *)*)
(*Table[{*)
(*Indexed[X, i]'[t] \[Equal]   (* each equation is for x-sub-i, ODE wrt t *)*)
(*(*Indexed[X,i][t]*      (* current pop density multiplied by...*)*)*)
(*(Indexed[X,i][t]*intrinsicGrowth[i,numberPlants]+ *)
(**)
(*Sum[consumerReproduction[i,j,numberPlants]*Indexed[X,i][t]*Indexed[A, {i,j}][t], {j,1,numberSpp }]-*)
(**)
(*vec\[Sigma][[i]]*Indexed[X,i][t]*Sum[Indexed[A,{i,j}][t]*(1-starvationMortality[i,j,numberPlants]),{j,1,numberPlants}]- (* sum is in the wrong place here *)*)
(**)
(*Sum[Indexed[X,i][t]*lossToHerbivory[i,j,numberPlants],{j,numberPlants,numberSpp }])},*)
(**)
(*{i,1,numberSpp}];*)*)
(**)
(*eqnX =       (* create a table of equations *)*)
(*Table[{*)
(*Indexed[X, i]'[t] ==   (* each equation is for x-sub-i, ODE wrt t *)*)
(*(*Indexed[X,i][t]*      (* current pop density multiplied by...*)*)*)
(*Indexed[X,i][t]*intrinsicGrowth[i,numberPlants]+ *)
(*Indexed[X,i][t]*Sum[consumerPopFunction[i,j,numberPlants],{j,1,numberPlants}]- *)
(*Indexed[X,i][t]*Sum[lossToHerbivory[i,j,numberPlants],{j,numberPlants+1,numberSpp }]},*)
(*{i,1,numberSpp}];*)
(**)
(*(*(*Define foraging effort equations*)*)
(*eqnA =   (* build matrix of foraging effort equations*)*)
(*Table[{*)
(*Indexed[A, {i,j}]'[t] \[Equal]*)
(*adjM[[i,j]]* (* if there isn't an interaction, the equation will = 0*)(G[[i]]*Indexed[A, {i,j}][t] * (* learning rate x current effort*)*)
(*(* conversion x foraging efficiency x prey density with assumption of 100% foraging effort *)*)
(*(consumerReproduction[i,j,numberPlants]-*)
(*(* sum of current foraging effort x conversion x efficiency x prey density for all prey interactions*)*)
(* Sum[consumerReproduction[i,k,numberPlants]Indexed[A, {i,k}][t], {k,1,numberSpp }]))},{i,1,numberSpp},{j,1,numberSpp}];*)*)
(**)
(*(*Define foraging effort equations*)*)
(*eqnA =   (* build matrix of foraging effort equations*)*)
(*Table[{*)
(*Indexed[A, {i,j}]'[t] ==*)
(*adjM[[i,j]]* (* if there isn't an interaction, the equation will = 0*)(G[[i]]*Indexed[A, {i,j}][t] * (* learning rate x current effort*)*)
(*(* conversion x foraging efficiency x prey density with assumption of 100% foraging effort *)*)
(*(consumerReproduction[i,j,numberPlants]-*)
(*(* sum of current foraging effort x conversion x efficiency x prey density for all prey interactions*)*)
(* Sum[consumerReproduction[i,k,numberPlants]Indexed[A, {i,k}][t], {k,1,numberPlants }]))},{i,numberPlants+1,numberSpp},{j,1,numberPlants}];*)
(**)
(*initialInteractionStrengths=initialInteraction[adjM,numberSpp];*)
(*(*Declare starting conditions*)*)
(*startcond =  (* joins and flattens a table of init pop densities (0-0.1) with a table of normalized init foraging efforts*)*)
(*Flatten[Join[{*)
(*Table[Indexed[X, i][0]==*)
(*If[i<= numberPlants,*)
(*vecK[[i]],*)
(*herbivoreAttributes[[i-numberPlants,3]] * Exp[damuthModelHC[Log[herbivoreAttributes[[i-numberPlants,3]]]]]],*)
(*(*RandomVariate[UniformDistribution[{0,10}]],*) *)
(*{i,1, numberSpp}],*)
(**)
(*Table[Indexed[A, {i,j}][0]==*)
(*initialInteractionStrengths[[i,j]], *)
(* {i,numberPlants+1,numberSpp},{j,1,numberPlants}]*)
(**)
(*}]];*)
(**)
(*(*Mathematica weirdness*)*)
(*varsX = Table[Indexed[X,i], {i,1, numberSpp}];(* makes vector of species variables*)*)
(*varsA= Table[Indexed[A,{i,j}], {i,numberPlants+1,numberSpp}, {j,1,numberPlants}]; (* makes vector of foraging effort variables*)*)
(*vars = Flatten[Join[varsX,varsA]]; (* makes one flat vector of variables out of species and efforts*)*)
(*(*events=WhenEvent[Evaluate[Indexed[X,#][t]<=10^(-10)],Indexed[X,#][t]\[Rule]0]&/@Range@numberSpp;*)*)
(*eqns =Flatten[Join[eqnX,eqnA]]; (* makes one flat list of equations and initial conditions*)*)
(**)
(*(*This step solves the equations*)*)
(*sol=NDSolve[{eqns,startcond(*,events*)}, vars, {t,1,T},Method->"StiffnessSwitching"](* solves equations from 1 to time T *)*)
(*)(*//Timing*)*)
(*]*)
(**)
(**)
(**)
(*(* combines interactions and generateFW into a single function call, outputs a dynamical system *)*)
(*fullModel[numberPlants_,herbivoreList_,connectance_,nicheModel_,perAdaptive_,scenario_,trophicModel_, T_]:=Module[*)
(*{},*)
(*interactionMatrixGenerator[numberPlants,herbivoreList,connectance,nicheModel,scenario,trophicModel];*)
(*adjG =AdjacencyGraph[interactionMatrix];*)
(*adjM = AdjacencyMatrix[adjG];*)
(*MatrixPlot[adjM,PlotLabel->"Interaction Matrix: Mass Pred + Rand Herbivore Ranges"];*)
(**)
(*generateFW[ numberPlants,herbivoreList,adjM,perAdaptive,scenario, T]*)
(*(*LogLinearPlot[Evaluate[varsX/.sol],{t,1,T},AxesOrigin\[Rule]{0,0},AspectRatio\[Rule]0.5,PlotRange\[Rule]All,Frame\[Rule]True]*)*)
(*]*)
(**)
(**)
(*(* below is a series of helper functions for the above code *)*)
(**)
(*(* completed new helper functions *)*)
(*logMassToNiche[mass_, minLogMass_, maxLogMass_,numberHerbivores_]:=*)
(*If[numberHerbivores<=1,*)
(*0.5, (* I need to think this default value through*)*)
(*(Log[mass]-minLogMass)/(maxLogMass-minLogMass)];*)
(**)
(**)
(*(* functions for determining the range of a consumer niche*)*)
(*randRange[]:=RandomReal[]*RandomVariate[BetaDistribution[alpha,beta]]*)
(*nicheModelRange[x_]:=x*RandomVariate[BetaDistribution[alpha,beta]]*)
(*inverseNicheModelRange[x_]:=(1.-x)*RandomVariate[BetaDistribution[alpha,beta]]*)
(*parabolicNicheModelRange[x_]:=(4.*(x-0.5)^2+0.2)*RandomVariate[BetaDistribution[alpha,beta]]*)
(**)
(*(* probability of interaction functions for predator/prey interactions *)*)
(*(* body size model parameterized by egypt paper *)*)
(*(* x is pred mass, y is prey mass *)*)
(*bodySizeModel[x_,y_]:=Exp[1.41+3.73*Log[x/y]+(-1.87)*Log[x/y]^2]*)
(*probInteract[x_,y_]:=bodySizeModel[x,y]/(1+bodySizeModel[x,y])*)
(**)
(*browseGrazeSpp[numberPlants_, scenario_]:=*)
(*(* input: number of spp and the resource scenario*)
(*output: number of browse spp and number of graze spp*)*)
(*Which[*)
(*scenario==1,*)
(*functionalNumberPlantSpp={numberPlants,0},*)
(*scenario==2,*)
(*functionalNumberPlantSpp={Floor[numberPlants*(3./4.)],Ceiling[numberPlants*(1./4.)]},*)
(*scenario==3,*)
(*If[OddQ[numberPlants],*)
(*If[RandomReal[]<=0.5,*)
(*functionalNumberPlantSpp={Ceiling[numberPlants*(2./4.)],Floor[numberPlants*(2./4.)]},*)
(*functionalNumberPlantSpp={Floor[numberPlants*(2./4.)],Ceiling[numberPlants*(2./4.)]}*)
(*],*)
(*functionalNumberPlantSpp={Round[numberPlants*(2./4.)],Round[numberPlants*(2./4.)]}*)
(*],*)
(*scenario==4,*)
(*functionalNumberPlantSpp={Ceiling[numberPlants*(1./4.)],Floor[numberPlants*(3./4.)]},*)
(*scenario==5,*)
(*functionalNumberPlantSpp={0,numberPlants}];*)
(**)
(*generatePlants[numberPlants_, scenario_]:=*)
(*Module[{},*)
(*(* randomly draw plant niches from uniform 0-1 *)*)
(*(* float-vec:{0.30450`,0.4319`,0.7096`}*)*)
(*plantNicheValue=  Sort[RandomVariate[UniformDistribution[{0,1.0}], numberPlants]];*)
(*plantID=Table[i,{i,1,numberPlants}]; (* ex. output: {1,2,3} *)*)
(**)
(*groups=browseGrazeSpp[numberPlants, scenario];*)
(*orderedTypes=Join[ConstantArray[0.,groups[[1]]],ConstantArray[1,groups[[2]]]];*)
(*randomTypes=RandomSample[orderedTypes];*)
(*(* plants: interlace the unique ID integer with niche *)*)
(*(* plant ex: {{1,0.3045`},{2,0.43198`},{3,0.7096`}}*)*)
(*plantAttributes=Thread[{plantID,plantNicheValue,randomTypes}]; *)
(*]*)
(**)
(*generateHerbivores[herbivoreList_,numberPlants_]:=*)
(*Module[{},*)
(*numberHerbivores=Length[herbivoreList];*)
(*numberSpp=numberHerbivores+numberPlants;*)
(*(* find the largest organism to set the log scale*)*)
(*maxMass=10.^8;(*Max[herbivoreList[[All,1]]];*) (* Int/float output*)*)
(*maxLogMass=Log[maxMass];(*Log10[Max[herbivoreList[[All,1]]]];*) (* Int/float output*)*)
(*minMass=10.^0;*)
(*minLogMass=Log[minMass];(*Log10[Min[herbivoreList[[All,1]]]];*) (* Int/float output*)*)
(*(* each species is given a unique Int ID number*)*)
(*	herbivoreID=Table[i,{i,numberPlants+1,numberSpp}]; (* ex. output: {4,5} *)*)
(*(* convert the log of herbiore mass to a niche value *)*)
(*(* if only two herbivores, values will be 0/1 *)*)
(*herbivoreNicheValue=Table[*)
(*logMassToNiche[herbivoreList[[i,1]],minLogMass, maxLogMass,numberHerbivores],*)
(*{i,1,numberHerbivores}];*)
(*(* herbs: interlace the unique ID integer with niche value and bodymass *)*)
(*(* herb ex: {4,0,100},{5,1,1000} *)*)
(*herbivoreAttributes=Thread[{herbivoreID,herbivoreNicheValue,herbivoreList[[All,1]],herbivoreList[[All,2]]}];*)
(*];*)
(**)
(**)
(**)
(*(* this revised version ensures all consumers are linked to at least one resource *)*)
(*herbivorePlantNicheLinks[plantAttributes_,herbivoreAttributes_,herbivoreNicheCenter_,herbivoreNicheMin_,herbivoreNicheMax_]:=Module[{},*)
(*nearestPlant=Table[Nearest[plantNicheValue->"Index",herbivoreNicheCenter[[i]]],{i,1,Length[herbivoreAttributes]}];*)
(*tLinks1=Table[*)
(*If[plantAttributes[[j,2]]>herbivoreNicheMin[[i]]&&plantAttributes[[j,2]]<herbivoreNicheMax[[i]],*)
(*plantAttributes[[j,1]],*)
(*0], *)
(*{i,1,Length[herbivoreAttributes]},{j,1,Length[plantAttributes]}];*)
(*Do[*)
(*If[Total[tLinks1[[i]]]==0,*)
(*tLinks1[[i,nearestPlant[[i]]]]=nearestPlant[[i]]],{i,1,Length[tLinks1]}];*)
(*tLinks1*)
(*];*)
(**)
(*herbivorePlantRatioLink[plant_,herbivore_]:=*)
(*(* this function takes a plant (number, niche, type) and a herbivore (number, niche, mass, ratio)*)
(*it returns the plant's ID or a zero *)*)
(*(* ratio meaning for modern herb data <-21 forest floor feeders, -21,-18 is forest canopy feeder, -17,-12 is mixed feeders, >-10 is grazers*)*)
(*(*-24, -7:  *)*)
(*{draw=RandomReal[];*)
(*herbValue=(herbivore[[4]]+24)/17;*)
(*Which[*)
(*plant[[3]]==0.&& draw>=  herbValue, (* browse*)*)
(*link=plant[[1]],*)
(*plant[[3]]==0.&& draw< herbValue,*)
(*link=0.,*)
(*plant[[3]]==1.&& draw> herbValue,  (* graze *)*)
(*link=0.,*)
(*plant[[3]]==1.&& draw<= herbValue,*)
(*link=plant[[1]]*)
(*]};*)
(**)
(**)
(*herbivorePlantRatioLinks[plantList_,herbivoreList_]:=*)
(*Module[{},*)
(*links=Table[*)
(*herbivorePlantRatioLink[plantList[[j]],herbivoreList[[i]]],*)
(*{i,1,Length[herbivoreList]},{j,1,Length[plantList]}];*)
(*Partition[Flatten[links],Length[plantList]]*)
(*];*)
(**)
(*nicheRatioLinks[nicheLinks_,ratioLinks_]:=*)
(*Module[{},*)
(*totalLinks=ConstantArray[0,Dimensions[ratioLinks]];*)
(*Table[If[ ratioLinks[[i,j]]==nicheLinks[[i,j]],*)
(*totalLinks[[i,j]]=ratioLinks[[i,j]],*)
(*0],*)
(*{i,1,Dimensions[ratioLinks][[1]]},{j,1,Dimensions[ratioLinks][[2]]}]];*)
(**)
(**)
(**)
(**)
(**)
(*(* helper functions for generating k *)*)
(*proportionGenerator[number_]:=*)
(*If[number>0,*)
(*stage1 = RandomReal[1,number];*)
(*stage2=stage1/Total[stage1]]*)
(**)
(*browseGrazeSpp[numberPlants_, scenario_]:=*)
(*(* input: number of spp and the resource scenario*)
(*output: number of browse spp and number of graze spp*)*)
(*Which[*)
(*scenario==1,*)
(*functionalNumberPlantSpp={numberPlants,0},*)
(*scenario==2,*)
(*functionalNumberPlantSpp={Floor[numberPlants*(3./4.)],Ceiling[numberPlants*(1./4.)]},*)
(*scenario==3,*)
(*If[OddQ[numberPlants],*)
(*If[RandomReal[]<=0.5,*)
(*functionalNumberPlantSpp={Ceiling[numberPlants*(2./4.)],Floor[numberPlants*(2./4.)]},*)
(*functionalNumberPlantSpp={Floor[numberPlants*(2./4.)],Ceiling[numberPlants*(2./4.)]}*)
(*],*)
(*functionalNumberPlantSpp={Round[numberPlants*(2./4.)],Round[numberPlants*(2./4.)]}*)
(*],*)
(*scenario==4,*)
(*functionalNumberPlantSpp={Ceiling[numberPlants*(1./4.)],Floor[numberPlants*(3./4.)]},*)
(*scenario==5,*)
(*functionalNumberPlantSpp={0,numberPlants}];*)
(**)
(*browseGrazeK[scenario_]:=*)
(*{systemK = RandomReal[{15000.,30000.}];*)
(*Which[*)
(*scenario==1,*)
(*resourceK={systemK,0.},*)
(*scenario==2,*)
(*resourceK={systemK*(3./4.),systemK*(1./4.)},*)
(*scenario==3,*)
(*resourceK={systemK*(2./4.),systemK*(2./4.)},*)
(*scenario==4,*)
(*resourceK={systemK*(1./4.),systemK*(3./4.)},*)
(*scenario==5,*)
(*resourceK={0.,systemK}]};*)
(**)
(*speciesKGenerator[resourceK_, numberPlantSpp_,scenario_]:=*)
(*(* resourceK is {browseK, grazeK}*)
(*   numberPlantSpp is {numBrowseSpp, numGrazeSpp}*)
(*want: {browsek1,..., browsekn, grazek1,..., grazekn *)*)
(*Which[*)
(*scenario==1,*)
(*browseSppK=proportionGenerator[numberPlantSpp[[1]]]*Flatten[resourceK][[1]],*)
(**)
(*scenario==2,*)
(* {browseSppK=proportionGenerator[numberPlantSpp[[1]]]*Flatten[resourceK][[1]],*)
(*grazeSppK=proportionGenerator[numberPlantSpp[[2]]]*Flatten[resourceK][[2]]},*)
(**)
(*scenario==3, *)
(*{browseSppK=proportionGenerator[numberPlantSpp[[1]]]*Flatten[resourceK][[1]],*)
(*grazeSppK=proportionGenerator[numberPlantSpp[[2]]]*Flatten[resourceK][[2]]},*)
(**)
(*scenario==4,*)
(* {browseSppK=proportionGenerator[numberPlantSpp[[1]]]*Flatten[resourceK][[1]],*)
(*grazeSppK=proportionGenerator[numberPlantSpp[[2]]]*Flatten[resourceK][[2]]},*)
(**)
(*scenario==5,*)
(*grazeSppK=proportionGenerator[numberPlantSpp[[2]]]*Flatten[resourceK][[2]]*)
(*]*)
(**)
(*carryingCapacityK[numberSpp_,scenario_]:=*)
(*(* *)
(*input: a resource scenario int [1,5], a number of plant species int*)
(*output: a vector of carrying capacities in g/m^2, the vector is ordered with browse first and graze second*)
(**)*)
(*Flatten[speciesKGenerator[browseGrazeK[scenario],browseGrazeSpp[numberSpp, scenario]]]*)
(**)
(**)
(*intrinsicGrowth[i_,numberPlants_]:=*)
(*If[i<=numberPlants,*)
(*(*r[[i]]-s[[i]]*Indexed[X,i][t],*)*)
(*r[[i]](1-Indexed[X,i][t]/vecK[[i]]),*)
(*0.];*)
(**)
(*starvationMortality[i_,j_,numberPlants_]:=*)
(*If[i>numberPlants && adjM[[i,j]]==1,*)
(*(*vec\[Sigma][[i]]*(1-Indexed[X,j][t]/vecK[[j]]) *Indexed[A,i,j][t],*)*)
(*Indexed[X,j][t]/vecK[[j]] (**Indexed[A,{i,j}][t]*),*)
(*0.*)
(*];*)
(**)
(*consumerPopFunction[i_,j_,numberPlants_]:=*)
(*If[i>numberPlants && adjM[[i,j]]==1,*)
(*Indexed[A, {i,j}][t]*(vec\[Lambda][[i]]*Indexed[X, j][t]/(Indexed[X, j][t]+0.5*vecK[[j]])-vec\[Sigma][[i]]*(1-Indexed[X,j][t]/vecK[[j]])),*)
(*0.*)
(*];*)
(**)
(**)
(*(*2*(s[[j]]/r[[j]])*vec\[Lambda][[i]]* Indexed[X, j][t]*Indexed[A, i,j][t]*)*)
(*consumerReproduction[i_,j_,numberPlants_]:=*)
(*If[i>numberPlants && adjM[[i,j]]==1,*)
(*vec\[Lambda][[i]]*Indexed[X, j][t]/(Indexed[X, j][t]+0.5*vecK[[j]]),*)
(*0.*)
(*];*)
(**)
(*(*(vec\[Lambda][[j]]/vecY[[j]])*2*(s[[i]]/r[[i]])*Indexed[A,j,i][t]* Indexed[X, j][t],*)*)
(*lossToHerbivory[i_,j_,numberPlants_]:=*)
(*If[i<=numberPlants&& j>numberPlants && adjM[[j,i]]==1,*)
(*vec\[Lambda][[j]]/vecY[[j,i]]*1/(Indexed[X, i][t]+0.5*vecK[[i]])*Indexed[X,j][t]*Indexed[A,{j,i}][t],*)
(*0.];*)
(**)
(*initialInteraction[adjacency_,numberSpp_]:=Module[*)
(*{},*)
(**)
(*dat1=Table[*)
(*If[Total[adjM[[i,All]]]>0,*)
(*adjM[[i,j]]*RandomVariate[UniformDistribution[{0,1}]],*)
(*0.], *)
(*{i,1, numberSpp},{j,1, numberSpp}];*)
(**)
(*dat2=Table[*)
(*If[Total[dat1[[i,All]]]>0,*)
(*dat1[[i,j]]/Total[dat1[[i,All]]],*)
(*0.],*)
(*{i,1, numberSpp},{j,1, numberSpp}]*)
(*];*)
(**)
(*damuthModelHC[x_]:=\!\(\**)
(*TagBox[*)
(*RowBox[{*)
(*RowBox[{"-", "4.459834805724958"}], "-", *)
(*RowBox[{"0.7768181657741325", "x"}]}],*)
(*Short[#, 2]& ]\);*)
(**)
(*multiRunWeb[numberPlants_,herbivoreList_,connectance_,nicheModel_,perAdaptive_,scenario_,trophicModel_, T_,numberRuns_]:=Module[{},*)
(*{*)
(**)
(*	interps={};*)
(*	*)
(*	numberSpp=numberPlants+Length[herbivoreList];*)
(*	(*T=tLength;*)*)
(*	runs=1;*)
(*	fails=0;*)
(**)
(*	While[runs<=numberRuns,*)
(*	output=fullModel[numberPlants,herbivoreList,connectance,nicheModel,perAdaptive,scenario,trophicModel, T];*)
(*         test=Total[Table[output[[1,i]][[2]][T], {i,1,numberSpp}]];*)
(*	If[test>10^10 ||test<-10^10,*)
(*	fails++,*)
(*	AppendTo[interps,output];*)
(*         *)
(*        runs++*)
(*]*)
(*];*)
(**)
(*interps}]*)
(*mammal1={{10^6.,-9.191456112767465`}};*)
(**)
(*mammal3={{10^2.,-16.464347592298516`},{10^4.,-12.791912541844368`},{10^6.,-9.191456112767465`}};*)
(**)
(*mammal5={{10^2.,-19.281444519325788`},{10^3.,-16.464347592298516`},{10^4.,-22.70715832304807`},{10^5.,-10.443001988900225`},{10^6.,-21.260372752988726`}};*)
(**)
(*mammal10={{10^0.,-9.170584662776644`},{10^1.,-19.281444519325788`},{10^2.,-16.464347592298516`},{10^3.,-12.791912541844368`},{10^3.5,-20.73138855864883`},{10^4.,-22.70715832304807`},{10^4.5,-15.48162113428004`},{10^5.,-9.191456112767465`},{10^6.,-10.443001988900225`},{10^7.,-21.260372752988726`}};*)
(**)
(*mammal15={{10^0.`,0.`},{10^1.05`,0.`},{10^1.75,0.`},{10^2.45`,0.`},{10^2.8,0.`},{10^3.15,0.`},{10^3.5,0.`},{10^3.85,0.`},{10^4.2`,0.`},{10^4.55,0.`},{10^4.9`,0.`},{10^5.25,0.`},{10^5.6,0.`},{10^6.3,0.`},{10^7,0.`}};*)
(**)
(*mammal20={{10^0.`,0.`},{10^0.35,0.`},{10^0.7,0.`},{10^1.05`,0.`},{10^1.4,0.`},{10^1.75,0.`},{10^2.1`,0.`},{10^2.45`,0.`},{10^2.8,0.`},{10^3.15,0.`},{10^3.5,0.`},{10^3.85,0.`},{10^4.2`,0.`},{10^4.55,0.`},{10^4.9`,0.`},{10^5.25,0.`},{10^5.6,0.`},{10^5.95`,0.`},{10^6.3,0.`},{10^7`,0.`}};*)
(**)
(**)
(*(* <-21 forest floor feeders, -21,-18 is forest canopy feeder, -17,-12 is mixed feeders, >-10 is grazers*)*)
(*modernHerbivoreData={{3000.,-20.937},{3000.,-16.951},{5000.,-18.914},{12000.,-18.794},{18000.,-19.757},{20000.,-17.284},{20000.,-11.986},{30000.,-7.974},{40000.,-21.137},{45000.,-8.736},{50000.,-18.133},{50000.,-9.389},{58000.,-8.754},{70000.,-17.918},{110000.,-6.898},{180000.,-9.481},{190000.,-24.341},{250000.,-24.958},{250000.,-11.465},{250000.,-8.319},{400000.,-18.244},{400000.,-7.374},{450000.,-11.01},{800000.,-19.955},{1000000.,-8.407}};*)
(**)
(*randomHerbivores[numberOfHerbivores_,minMassExp_,maxMassExp_]:=Table[*)
(*{10^RandomReal[{minMassExp,maxMassExp}],RandomReal[]},{numberOfHerbivores}];*)
(**)
(**)
(*tLength=10.^12;*)
(**)
(**)
(**)


(* ::Input:: *)
(*(*output=fullModel[4,mammal3,0.3,2,1,3,0,tLength];*)
(**)
(*LogLogPlot[Evaluate[Table[Indexed[X,i][t]/.sol,{i,numberSpp}]],{t,1,tLength},AxesOrigin\[Rule]{0,0},AspectRatio\[Rule]0.5,PlotRange\[Rule]{10^-6,All},FrameLabel\[Rule]{"Time","Pop. Density"},Frame\[Rule]True(*PlotLegends\[Rule]Placed[{"Resource 1", "Resource 2", "Consumer 1", "Consumer 2", "Consumer 3", "Consumer 4"},After]*)]*)
(**)
(*focal=5;*)
(*LogLogPlot[Evaluate[Indexed[X,focal][t]/.sol],{t,1,tLength},AxesOrigin\[Rule]{0,0},AspectRatio\[Rule]0.5,PlotRange\[Rule]Full,FrameLabel\[Rule]{"Time","Pop. Density"},Frame\[Rule]True]*)
(**)
(*LogLinearPlot[Evaluate[Table[Indexed[A,{focal,j}][t]/.sol,{j,numberSpp}],{t,1,tLength}],AspectRatio\[Rule]0.5,AxesOrigin\[Rule]{0,0},PlotRange\[Rule]All,FrameLabel\[Rule]{"Time","Foraging Effort"},Frame\[Rule]True]*)*)


(* ::Input:: *)
(*(*  input variables for the runs         *)*)
(*numberOfPlants=10;*)
(*numberOfRuns=25;*)
(*numberOfHerbivores=10;*)
(*mammals=randomHerbivores[numberOfHerbivores,1,7];*)
(*nicheModel=2; (* normal niche model is 1, inverse niche is 2, parabolic niche is 3*)*)
(*trophicModel=1; (* full connectance is 0, a niche model (set above) is 1*)*)
(*scenario=3; (* 1 is forest, 3 is mixed, 5 is grassland *)*)
(*tLength=10^12;*)
(**)
(**)
(*(*Timing[ParallelDo[*)*)
(*(* numberPlants_,herbivoreList_,connectance_,nicheModel_,perAdaptive_,scenario_,trophicModel_, T_, numberRuns_*)*)
(*mRData=Flatten[multiRunWeb[numberOfPlants,mammals,0.3,nicheModel,1,scenario,trophicModel,tLength,numberOfRuns],1];*)
(**)
(*(*Export[StringJoin["~/Documents/science/code/thesis_code/adaptive_food_webs/simulation_data/",TextString[adap],"_plants:",TextString[pl],"_niche:",TextString[nimod],"_scene:",TextString[scene],"_trophy:",TextString[troph],"_runs:",TextString[2],".mx"],mRData],*)*)
(**)
(*(*{pl,{10}}, {nimod,{2}}, {adap,{1}}, {scene,{3}},{troph,{1}}]]*)*)


(* ::Input:: *)
(*dataFormat[data_,numberPlants_,numberHerbs_,numberRuns_,T_]:=Module[{},*)
(**)
(*pops=getPopData[data,numberPlants,numberHerbs,numberRuns,T];*)
(*initialForaging=getForageData[partitionForaging[data,numberPlants,numberHerbs,numberRuns],numberPlants,numberHerbs,numberRuns,1];*)
(*finalForaging=getForageData[partitionForaging[data,numberPlants,numberHerbs,numberRuns],numberPlants,numberHerbs,numberRuns,T];*)
(*Join[{{}},{pops},{initialForaging},{finalForaging}]*)
(*];*)
(**)
(*getPopData[data_,numberPlants_,numberHerbs_,numberRuns_,t_]:=*)
(*Table[data[[i,j]][[2]][t],{i,1,numberRuns},{j,1,numberPlants+numberHerbs}];*)
(**)
(*partitionForaging[data_,numberPlants_,numberHerbs_,numberRuns_]:=*)
(*Table[Partition[Table[data[[i,numberPlants+numberHerbs+1;;numberPlants*numberHerbs+numberPlants+numberHerbs]],{i,1,numberRuns}][[j]],10],{j,1,numberRuns}];*)
(**)
(*getForageData[data_,numberPlants_,numberHerbs_,numberRuns_,t_]:=*)
(*Table[data[[i,j,k]][[2]][t],{i,1,numberRuns},{j,1,numberHerbs},{k,1,numberPlants}]*)
(**)
(*(* mean body mass *)*)
(*meanBodyMass[communityData_,herbivores_,numberPlants_,run_]:=*)
(*(* total consumer biomass density (g/m2) / consumer numerical density (1/m2) = average body mass (g) *)*)
(*Sum[communityData[[run,i]],{i,numberPlants+1, Length[communityData[[1]]]}]/Sum[communityData[[run,i]] /herbivores[[i-10,1]],{i,numberPlants+1,Length[communityData[[1]]]}];*)
(**)
(*(* this finders the average mean body mass of a community over a number of runs*)*)
(*averageMeanBodyMass[communityData_,herbivores_,numberPlants_]:=*)
(*Sum[meanBodyMass[communityData,herbivores,numberPlants,run],{run,1,Length[communityData]}]/Length[communityData];*)
(**)
(*(* *)*)
(*massBiomassData[communityData_,herbivores_,numberPlants_]:=Table[*)
(*{Sum[communityData[[j,i]],{i,numberPlants+1,numberPlants+Length[herbivores]}],meanBodyMass[communityData,herbivores,numberPlants,j]},*)
(*{j,1,Length[communityData]}];*)
(**)
(*processedMRData=dataFormat[Flatten[mRData,1],numberOfPlants,numberOfHerbivores,numberOfRuns,tLength];*)
(**)
(*massBiomassInvNiche=massBiomassData[processedMRData[[2]],mammals, numberOfPlants];*)


(* ::Input:: *)
(*logMassBiomassInvNicheLinearModel=LinearModelFit[Log@massBiomassInvNiche,x,x];*)
(**)
(*p1=Show[*)
(*ListLogLogPlot[massBiomassInvNiche,Frame->True,PlotRange->{{0,100},{10^-1,10^8}},FrameLabel->{{"Mean Body Mass (g)",""},{"Community Biomass (g/m^2)", "Inverse Niche Model"}}],*)
(*Plot[logMassBiomassInvNicheLinearModel[x],{x,-10.0,100}, PlotStyle->{}],*)
(*LogLogPlot[1.5*10^5-0.02*x,{x,0,100}, PlotRange->{10^0,10^8},PlotStyle->{Dashed}]*)
(*]*)
(**)
(*Export[StringJoin[{$HomeDirectory,"/herbivoredynamics/communitydynamics/fig_hatton.pdf"}],p1]*)


(* ::Input:: *)
(**)
